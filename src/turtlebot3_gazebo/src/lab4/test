#!/usr/bin/env python3

import rclpy
from rclpy.node import Node

from sensor_msgs.msg import LaserScan
from nav_msgs.msg import OccupancyGrid, Odometry
from geometry_msgs.msg import Twist
import numpy as np
import math
import time
import heapq
from collections import deque

# ---------- TUNABLE PARAMETERS ----------
OCCUPIED_THRESH = 50          # occupancy grid value >= this is considered an obstacle
UNKNOWN_VAL = -1
INFLATE_RADIUS = 4            # smaller by default; adjust if robot footprint requires
GOAL_NEAR_DIST_M = 0.12       # when within this world distance to goal waypoint, pop waypoint
ALIGN_ANGLE = 0.20            # radians: how close to aligned before driving forward
MAX_LINEAR_SPEED = 0.2
MAX_ANGULAR_SPEED = 0.6
OBSTACLE_FRONT_THRESH = 0.30  # meters
REPLAN_INTERVAL = 1.0         # seconds between forced replans
STUCK_TIME = 3.0              # seconds to consider stuck
STUCK_MOVE_THRESH = 0.05      # meters moved to consider not stuck
BACKUP_TIME = 0.6             # seconds to back up on recovery
RECOVERY_ROTATE_TIME = 1.0    # seconds to rotate during recovery
MIN_FRONTIER_GRID_DIST = 8    # minimum grid cells away from robot to accept frontier
# ----------------------------------------

class Task1(Node):

    def __init__(self):
        super().__init__('task1_node')

        # Subscribers
        self.create_subscription(LaserScan, '/scan', self.scan_callback, 10)
        self.create_subscription(Odometry, '/odom', self.odom_callback, 10)
        self.create_subscription(OccupancyGrid, '/map', self.map_callback, 10)

        # Publisher
        self.cmd_pub = self.create_publisher(Twist, '/cmd_vel', 10)

        self.timer = self.create_timer(0.1, self.timer_cb)

        # Robot pose
        self.robot_x = 0.0
        self.robot_y = 0.0
        self.robot_yaw = 0.0

        # Map
        self.map_data = None
        self.map_width = 0
        self.map_height = 0
        self.map_res = 0.05
        self.map_origin = (0.0, 0.0)
        self.map_seq = 0  # increment on map 
        self.inflated_map = None

        # LIDAR
        self.front = 10.0
        self.left = 10.0
        self.right = 10.0
        self.ranges_full = None

        # Planner state
        self.current_path = []          # list of waypoints in grid (gx,gy)
        self.current_path_world = []    # list of waypoints in world coords (wx,wy)
        self.path_goal = None           # grid goal (gx,gy)
        self.last_plan_time = 0.0

        # Stuck detection
        self.last_pos = (0.0, 0.0)
        self.last_movement_time = time.time()
        self.last_cmd = Twist()

        # Recovery
        self.recovering = False
        self.recovery_end_time = 0.0
        self.recovery_stage = None  # "backup" or "rotate"

        self.get_logger().info("üåç Task1 exploration (A*-based) node started.")

    # ---------------- TIMER LOOP ----------------
    def timer_cb(self):
        # If we are in recovery, run recovery behavior
        now = time.time()
        if self.recovering:
            if now < self.recovery_end_time:
                self.cmd_pub.publish(self.recovery_cmd())
                return
            else:
                # finish recovery
                self.recovering = False
                self.recovery_stage = None
                self.get_logger().info("üîÅ Recovery finished, replanning.")
                # clear path to force replan
                self.current_path = []
                self.current_path_world = []
                self.path_goal = None

        # if no map yet, rotate slowly to get SLAM started
        if self.map_data is None:
            cmd = Twist()
            cmd.angular.z = 0.4
            self.cmd_pub.publish(cmd)
            return

        # Check stuck while driving forward
        if hasattr(self, "last_cmd") and getattr(self.last_cmd, "linear", None) is not None:
            if self.last_cmd.linear.x > 0.03:
                dx = self.robot_x - self.last_pos[0]
                dy = self.robot_y - self.last_pos[1]
                moved = math.hypot(dx, dy)
                if moved > STUCK_MOVE_THRESH:
                    self.last_movement_time = now
                    self.last_pos = (self.robot_x, self.robot_y)
                else:
                    if now - self.last_movement_time > STUCK_TIME:
                        self.get_logger().warning("üõë Stuck detected -> performing recovery")
                        self.start_recovery()
                        self.cmd_pub.publish(self.recovery_cmd())
                        self.last_cmd = self.recovery_cmd()
                        return

        # If there is a current valid path, follow it
        if self.current_path and len(self.current_path_world) > 0:
            # emergency obstacle check while following path
            """if hasattr(self, "front") and self.front < OBSTACLE_FRONT_THRESH:
                self.get_logger().info("üöß Obstacle detected while following path -> replan")
                self.current_path = []
                self.current_path_world = []
                self.path_goal = None
                # publish a stop to help SLAM and lidar update
                self.cmd_pub.publish(Twist())
                return"""

            cmd = self.follow_path()
            self.cmd_pub.publish(cmd)
            self.last_cmd = cmd
            return

        # otherwise plan a new path to a reachable frontier
        if time.time() - self.last_plan_time > REPLAN_INTERVAL or not self.current_path:
            planned = self.plan_to_frontier(farthest=False)
            self.last_plan_time = time.time()
            if not planned:
                # nothing to plan (no reachable frontiers)
                self.get_logger().info("üéâ Map complete (or no reachable frontiers). Stopping.")
                self.cmd_pub.publish(Twist())
                return

        # In case planning returned a path but we didn't publish yet, publish stop as default
        self.cmd_pub.publish(Twist())

    # ---------------- LIDAR ----------------
    def scan_callback(self, msg):
        ranges = np.array(msg.ranges)
        ranges = np.where(np.isfinite(ranges), ranges, 10.0)
        self.ranges_full = ranges
        N = len(ranges)
        self.front = np.min(ranges[int(N*0.45):int(N*0.55)])
        self.left  = np.min(ranges[int(N*0.25):int(N*0.45)])
        self.right = np.min(ranges[int(N*0.55):int(N*0.75)])

    # ---------------- ODOM ----------------
    def odom_callback(self, msg):
        self.robot_x = msg.pose.pose.position.x
        self.robot_y = msg.pose.pose.position.y
        q = msg.pose.pose.orientation
        siny = 2*(q.w*q.z + q.x*q.y)
        cosy = 1 - 2*(q.y*q.y + q.z*q.z)
        self.robot_yaw = math.atan2(siny, cosy)

    # ---------------- MAP ----------------
    def map_callback(self, msg):
        # msg.data is a flat list row-major. reshape to [height, width]
        self.map_data = np.array(msg.data, dtype=int).reshape(msg.info.height, msg.info.width)
        self.map_width = msg.info.width
        self.map_height = msg.info.height
        self.map_res = msg.info.resolution
        self.map_origin = (msg.info.origin.position.x, msg.info.origin.position.y)
        # bump seq to notice map changes
        self.map_seq += 1

        # build inflated map (binary grid) whenever map updates
        self.inflated_map = self.build_inflated_map(self.map_data, INFLATE_RADIUS)

    # ---------------- INFLATION ----------------
    def build_inflated_map(self, M, radius_cells):
        """
        Returns binary map same shape as M:
         - 1 means occupied or inflated-occupied
         - 0 means free or unknown (we treat unknown as passable here)
        We consider original occupied if M >= OCCUPIED_THRESH.
        """
        H, W = M.shape
        binmap = np.zeros((H, W), dtype=np.uint8)
        # mark occupied cells (from original occupancy grid)
        binmap[M >= OCCUPIED_THRESH] = 1

        if radius_cells <= 0:
            return binmap

        # BFS-style dilation from occupied cells
        inflated = binmap.copy()
        dist = np.full((H, W), -1, dtype=int)
        q = deque()

        ys, xs = np.where(binmap == 1)
        for y, x in zip(ys, xs):
            q.append((y, x))
            dist[y, x] = 0

        # 8-connected offsets
        offs = [(-1,0),(1,0),(0,-1),(0,1),(-1,-1),(-1,1),(1,-1),(1,1)]

        while q:
            y, x = q.popleft()
            d = dist[y, x]
            if d >= radius_cells:
                continue
            for dy, dx in offs:
                ny, nx = y + dy, x + dx
                if 0 <= ny < H and 0 <= nx < W and dist[ny, nx] == -1:
                    dist[ny, nx] = d + 1
                    inflated[ny, nx] = 1
                    q.append((ny, nx))

        return inflated

    # ---------------- FRONTIER / PLANNING HELPERS ----------------
    def get_frontier_cells(self):
        """
        Return list of free cells (x,y) that border unknown cells.
        free cell: map_data[y,x] == 0
        unknown cell: map_data[y,x] == UNKNOWN_VAL
        """
        if self.map_data is None:
            return []

        frontiers = []
        M = self.map_data
        H, W = M.shape

        # don't check border cells (1..H-2, 1..W-2) for safety
        for y in range(1, H-1):
            for x in range(1, W-1):
                if M[y, x] != 0:
                    continue
                # check 8-neighborhood for unknown
                neigh = M[y-1:y+2, x-1:x+2]
                if np.any(neigh == UNKNOWN_VAL):
                    frontiers.append((x, y))
        return frontiers

    def is_cell_free_inflated(self, gx, gy):
        """Return True if inflated_map considers this cell free (0)."""
        if self.inflated_map is None:
            return False
        if not (0 <= gx < self.map_width and 0 <= gy < self.map_height):
            return False
        return self.inflated_map[gy, gx] == 0

    # -----------------------------------------------------
    #      PLANNING: choose reachable frontier -> A*
    # -----------------------------------------------------
    def plan_to_frontier(self, farthest=False):
        if self.map_data is None or self.inflated_map is None:
            return False

        H, W = self.map_height, self.map_width

        # gather frontier cells (free cells adjacent to unknown)
        frontiers = self.get_frontier_cells()
        self.get_logger().info(f"Found frontiers: {len(frontiers)}  Inflated occupied: {np.sum(self.inflated_map==1)}")

        if not frontiers:
            return False

        # Robot position in grid (gx,gy)
        rx, ry = self.world_to_grid(self.robot_x, self.robot_y)
        # sanity: ensure robot cell is free in inflated map
        robot_inflated = self.inflated_map[ry, rx] if self.inflated_map is not None else 1
        self.get_logger().info(f"Robot grid = {(rx, ry)}  inflated_occupied={robot_inflated}")

        if robot_inflated == 1:
            self.get_logger().warn("Robot is inside inflated obstacle! Trying to continue but consider reducing INFLATE_RADIUS.")
            # attempt to continue: allow planning but A* start may fail

        # Convert to numpy array for vectorized distance compute
        F = np.array(frontiers)   # shape (N, 2) with columns [x, y]
        dx = F[:,0] - rx
        dy = F[:,1] - ry
        dist_sq = dx*dx + dy*dy

        # prioritize OUTWARD direction:
        order = np.argsort(dist_sq)[::-1]   # farthest first


        # attempt each frontier in order until A* finds a path
        tried = 0
        for idx in order:
            fx, fy = int(F[idx,0]), int(F[idx,1])
            tried += 1

            # skip frontiers that are too close to robot (same or adjacent cells)
            if math.hypot(fx - rx, fy - ry) < MIN_FRONTIER_GRID_DIST:
                # debug log occasional skipping
                if tried <= 10:
                    self.get_logger().debug(f"Skipping near frontier {(fx,fy)} dist={math.hypot(fx-rx,fy-ry)}")
                continue

            # skip if the frontier cell itself is not free in inflated map (safety)
            if not self.is_cell_free_inflated(fx, fy):
                self.get_logger().debug(f"Frontier {(fx,fy)} is blocked by inflation.")
                continue

            # Attempt A* directly to the frontier cell (free cell)
            start = (rx, ry)
            goal = (fx, fy)
            path = self.astar_grid(start, goal)
            if path:
                # store path (grid coords)
                self.current_path = path
                self.current_path_world = [self.grid_to_world(gx, gy) for gx, gy in path]
                self.path_goal = goal
                self.get_logger().info(f"üìç Planned path to frontier goal grid={goal} path_len={len(path)} tried={tried}")
                # reset stuck detection trackers
                self.last_pos = (self.robot_x, self.robot_y)
                self.last_movement_time = time.time()
                return True
            else:
                self.get_logger().debug(f"A* failed for frontier {(fx,fy)} (tried {tried})")
                continue

        # no reachable frontier found
        self.get_logger().info("No reachable frontier found after trying candidates.")
        return False

    # -----------------------------------------------------
    #               A* ON GRID (4-connected)
    # -----------------------------------------------------
    def astar_grid(self, start, goal):
        # start, goal are (gx,gy) tuples
        sx, sy = start
        gx, gy = goal
        H, W = self.map_height, self.map_width

        # bounds
        if not (0 <= gx < W and 0 <= gy < H):
            return None

        # Use inflated_map for occupancy checks (1 == occupied)
        M_infl = self.inflated_map
        # if goal is occupied in inflated map -> fail
        if M_infl[gy, gx] == 1:
            return None
        if M_infl[sy, sx] == 1:
            # start inside obstacle; fail gracefully
            return None

        open_heap = []
        heapq.heappush(open_heap, (0 + self.heuristic(start, goal), 0, start, None))
        came_from = {}
        gscore = {start: 0}
        closed = set()

        neighbors = [(1,0), (-1,0), (0,1), (0,-1)]

        while open_heap:
            f, g, current, parent = heapq.heappop(open_heap)
            if current in closed:
                continue
            came_from[current] = parent
            if current == goal:
                # reconstruct path
                path = []
                node = current
                while node is not None:
                    path.append(node)
                    node = came_from[node]
                path.reverse()
                return path  # list of (gx,gy)
            closed.add(current)

            cx, cy = current
            for dx, dy in neighbors:
                nx, ny = cx + dx, cy + dy
                if not (0 <= nx < W and 0 <= ny < H):
                    continue
                if M_infl[ny, nx] == 1:
                    continue
                neighbor = (nx, ny)
                tentative_g = g + 1
                if tentative_g < gscore.get(neighbor, 1e9):
                    gscore[neighbor] = tentative_g
                    fscore = tentative_g + self.heuristic(neighbor, goal)
                    heapq.heappush(open_heap, (fscore, tentative_g, neighbor, current))

        return None

    def heuristic(self, a, b):
        # Euclidean distance in grid cells
        return math.hypot(a[0]-b[0], a[1]-b[1])

    # -----------------------------------------------------
    #                PATH FOLLOWER
    # -----------------------------------------------------
    def follow_path(self):
        """
        Follow current_path_world waypoints. Returns Twist command.
        """
        if not self.current_path_world:
            return Twist()

        # next waypoint in world coords
        wx, wy = self.current_path_world[0]

        dx = wx - self.robot_x
        dy = wy - self.robot_y
        dist = math.hypot(dx, dy)
        target_angle = math.atan2(dy, dx)
        yaw_error = target_angle - self.robot_yaw
        yaw_error = math.atan2(math.sin(yaw_error), math.cos(yaw_error))

        cmd = Twist()

        # If close to waypoint, pop it
        if dist < GOAL_NEAR_DIST_M:
            self.current_path_world.pop(0)
            self.current_path.pop(0)
            # if path finished
            if not self.current_path_world:
                self.get_logger().info("‚úÖ Reached path goal grid={}, clearing path".format(self.path_goal))
                self.path_goal = None
            return Twist()

        # Safety override: if obstacle directly in front, rotate in place
        if hasattr(self, "front") and self.front < 0.28:
            cmd.linear.x = 0.0
            # rotate away from obstacle using side readings
            if hasattr(self, "left") and hasattr(self, "right"):
                if self.left < self.right:
                    cmd.angular.z = -0.5
                else:
                    cmd.angular.z = 0.5
            else:
                cmd.angular.z = 0.5
            return cmd

        # rotate to face waypoint first if yaw error large
        if abs(yaw_error) > ALIGN_ANGLE:
            # rotate proportionally, no forward
            ang = 1.2 * yaw_error
            ang = max(-MAX_ANGULAR_SPEED, min(MAX_ANGULAR_SPEED, ang))
            cmd.angular.z = ang
            cmd.linear.x = 0.0
            return cmd

        # else drive forward with small angular correction
        cmd.linear.x = min(MAX_LINEAR_SPEED, 0.5 * dist + 0.02)
        # damp speed when near obstacles
        if hasattr(self, "front") and self.front < 0.6:
            cmd.linear.x = min(cmd.linear.x, 0.06)
        cmd.angular.z = max(-MAX_ANGULAR_SPEED, min(MAX_ANGULAR_SPEED, 1.0*yaw_error))
        return cmd

    # -----------------------------------------------------
    #                RECOVERY BEHAVIOR
    # -----------------------------------------------------
    def start_recovery(self):
        # start backup stage first then rotate
        self.recovering = True
        self.recovery_stage = "backup"
        self.recovery_end_time = time.time() + BACKUP_TIME

    def recovery_cmd(self):
        cmd = Twist()
        if self.recovery_stage == "backup":
            # back up slowly
            cmd.linear.x = -0.06
            cmd.angular.z = 0.0
            # if time passed, move to rotate
            if time.time() >= self.recovery_end_time:
                self.recovery_stage = "rotate"
                self.recovery_end_time = time.time() + RECOVERY_ROTATE_TIME
                return cmd
            return cmd
        elif self.recovery_stage == "rotate":
            # rotate in place
            cmd.linear.x = 0.0
            cmd.angular.z = 0.6
            return cmd
        else:
            return Twist()

    # -----------------------------------------------------
    #             MAP <-> WORLD helpers
    # -----------------------------------------------------
    def world_to_grid(self, wx, wy):
        gx = int((wx - self.map_origin[0]) / self.map_res)
        gy = int((wy - self.map_origin[1]) / self.map_res)
        # clamp
        gx = max(0, min(self.map_width - 1, gx))
        gy = max(0, min(self.map_height - 1, gy))
        return gx, gy

    def grid_to_world(self, gx, gy):
        wx = self.map_origin[0] + gx * self.map_res + 0.5*self.map_res
        wy = self.map_origin[1] + gy * self.map_res + 0.5*self.map_res
        return wx, wy

def main(args=None):
    rclpy.init(args=args)
    node = Task1()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
