#!/usr/bin/env python3

import rclpy
from rclpy.node import Node

from sensor_msgs.msg import LaserScan
from nav_msgs.msg import OccupancyGrid, Odometry
from geometry_msgs.msg import Twist
import numpy as np
import math
import time
import heapq
from collections import deque

# ---------- TUNABLE PARAMETERS ----------
OCCUPIED_THRESH = 50          # occupancy grid value >= this is considered an obstacle
UNKNOWN_VAL = -1
INFLATE_RADIUS = 4            # smaller by default; adjust if robot footprint requires
GOAL_NEAR_DIST_M = 0.15       # when within this world distance to goal waypoint, pop waypoint
ALIGN_ANGLE = 0.20            # radians: how close to aligned before driving forward
MAX_LINEAR_SPEED = 0.4
MAX_ANGULAR_SPEED = 0.6
OBSTACLE_FRONT_THRESH = 0.40  # meters
REPLAN_INTERVAL = 1.0         # seconds between forced replans
STUCK_TIME = 4.0              # seconds to consider stuck
STUCK_MOVE_THRESH = 0.05      # meters moved to consider not stuck
BACKUP_TIME = 0.6             # seconds to back up on recovery
RECOVERY_ROTATE_TIME = 1.0    # seconds to rotate during recovery
MIN_FRONTIER_GRID_DIST = 6    # minimum grid cells away from robot to accept frontier
# ----------------------------------------

class Task1(Node):

    def __init__(self):
        super().__init__('task1_node')

        # Subscribers
        self.create_subscription(LaserScan, '/scan', self.scan_callback, 10)
        self.create_subscription(Odometry, '/odom', self.odom_callback, 10)
        self.create_subscription(OccupancyGrid, '/map', self.map_callback, 10)

        # Publisher
        self.cmd_pub = self.create_publisher(Twist, '/cmd_vel', 10)
        self.timer = self.create_timer(0.1, self.timer_cb)

        # Robot pose
        self.robot_x = 0.0
        self.robot_y = 0.0
        self.robot_yaw = 0.0

        # Map
        self.map_data = None
        self.inflated_map = None
        self.map_width = 0
        self.map_height = 0
        self.map_res = 0.05
        self.map_origin = (0.0, 0.0)
        self.map_seq = 0  # increment on map 

        # LIDAR
        self.front = 10.0
        self.left = 10.0
        self.right = 10.0
        self.ranges_full = None

        # Planner state
        self.current_path = []          # list of waypoints in grid (gx,gy)
        self.current_path_world = []    # list of waypoints in world coords (wx,wy)
        self.path_goal = None           # grid goal (gx,gy)
        self.last_plan_time = 0.0

        # Stuck detection
        self.last_pos = (0.0, 0.0)
        self.last_movement_time = time.time()
        self.last_cmd = Twist()

        # oscillation detection (simple sign-flip detector)
        self.last_turn_sign = 0
        self.osc_count = 0
        self.OSCILLATION_THRESHOLD = 4
        self.OSCILLATION_COOLDOWN = 3.0
        self.osc_last_time = 0.0
        self.oscillating = False
        self.osc_end = 0.0

        # Recovery
        self.recovering = False
        self.recovery_end_time = 0.0
        self.recovery_stage = None  # "backup" or "rotate"

        # Exploration bias: persistent exploration direction in world coords (unit vector)
        # Set to None initially; once we pick a first frontier we store the direction to keep going.
        self.exploration_dir = None
        self.EXPLORE_ANGLE_LIMIT = math.radians(60)   # cone +/- 60 degrees

        # frontier visit bookkeeping
        self.visited_mask = None           # numpy bool array same shape as map
        self.VISITED_RADIUS = 10            # radius in grid cells to mark visited around goals (tune)
        self.failed_frontiers = {}         # dict {(gx,gy): fail_count}
        self.FAILED_LIMIT = 3              # after this many A* fails, temporarily ignore frontier
        self.FAILED_CLEAR_TIME = 15.0      # seconds after which failed_frontiers entry may be dropped
        self._failed_timestamps = {}       # {(gx,gy): last_fail_time}

        self.get_logger().info("Task 1 node started.")

    # ---------------- TIMER LOOP ----------------
    def timer_cb(self):
        now = time.time()

        # ---------------- RECOVERY ----------------
        if self._handle_recovery(now):
            return

        # ---------------- OSCILLATION ----------------
        if self._handle_oscillation(now):
            return

        # ---------------- MAP NOT READY ----------------
        if self.map_data is None:
            self._publish_rotate()
            return

        # ---------------- STUCK CHECK ----------------
        if self._check_stuck(now):
            return

        # ---------------- FOLLOW CURRENT PATH ----------------
        if self.current_path and self.current_path_world:
            cmd = self.follow_path()
            self.cmd_pub.publish(cmd)
            self.last_cmd = cmd
            return

        # ---------------- PLAN NEW PATH ----------------
        if now - self.last_plan_time > REPLAN_INTERVAL or not self.current_path:
            if not self.plan_to_frontier(farthest=False):
                self.get_logger().info("üéâ Map complete (or no reachable frontiers). Stopping.")
                self.cmd_pub.publish(Twist())
                return
            self.last_plan_time = now

        # Default
        self.cmd_pub.publish(Twist())

    def _handle_recovery(self, now):
        if not self.recovering:
            return False

        # still in recovery
        if now < self.recovery_end_time:
            self.cmd_pub.publish(self.recovery_cmd())
            return True

        # exit recovery
        self.recovering = False
        self.recovery_stage = None
        self.get_logger().info("üîÅ Recovery finished, replanning.")
        self._reset_path()
        return False
    
    def _handle_oscillation(self, now):
        if not self.oscillating:
            return False

        if now < self.osc_end:
            cmd = Twist(); cmd.linear.x = 0.12
            self.cmd_pub.publish(cmd)
            return True

        self.oscillating = False
        return False
    
    def _publish_rotate(self):
        cmd = Twist()
        cmd.angular.z = 0.4
        self.cmd_pub.publish(cmd)

    def _check_stuck(self, now):
        if not hasattr(self, "last_cmd"):
            return False

        if getattr(self.last_cmd, "linear", None) is None:
            return False

        if self.last_cmd.linear.x <= 0.03:
            return False

        dx = self.robot_x - self.last_pos[0]
        dy = self.robot_y - self.last_pos[1]
        moved = math.hypot(dx, dy)

        if moved > STUCK_MOVE_THRESH:
            self.last_movement_time = now
            self.last_pos = (self.robot_x, self.robot_y)
            return False

        if now - self.last_movement_time > STUCK_TIME:
            self.get_logger().warning("üõë Stuck detected -> performing recovery")
            self.start_recovery()
            rc = self.recovery_cmd()
            self.cmd_pub.publish(rc)
            self.last_cmd = rc
            return True

        return False
    
    def _reset_path(self):
        self.current_path = []
        self.current_path_world = []
        self.path_goal = None

    # ---------------- LIDAR ----------------
    def scan_callback_old(self, msg):
        ranges = np.array(msg.ranges)
        ranges = np.where(np.isfinite(ranges), ranges, 10.0)
        self.ranges_full = ranges
        N = len(ranges)
        # front: central ¬±10-12% (robust to different lidar indexing)
        i0 = int(N * 0.44); i1 = int(N * 0.56)
        sector = ranges[i0:i1]
        self.front = float(np.percentile(sector, 5))  # ignores single outliers
        """if i0 <= i1:
            self.front = float(np.min(ranges[i0:i1]))
        else:
            self.front = float(min(np.min(ranges[i0:]), np.min(ranges[:i1])))"""
        # left/right sectors (20%-35% and 65%-80%)
        self.left = float(np.min(ranges[int(N*0.20):int(N*0.35)]))
        self.right = float(np.min(ranges[int(N*0.65):int(N*0.80)]))
    
    # ---------------- LIDAR ----------------
    def scan_callback_old2(self, msg):
        ranges = np.array(msg.ranges, dtype=float)
        ranges = np.where(np.isfinite(ranges), ranges, 10.0)
        self.ranges_full = ranges
        N = len(ranges)

        # FRONT sector: central 12% (good for TB3)
        i0 = int(0.44 * N)
        i1 = int(0.56 * N)
        front_sector = ranges[i0:i1]
        # ignore outliers ‚Üí more stable
        self.front = float(np.percentile(front_sector, 5))

        # SIDE sectors (use percentiles for stability)
        left_sec  = ranges[int(0.20*N):int(0.35*N)]
        right_sec = ranges[int(0.65*N):int(0.80*N)]

        self.left  = float(np.percentile(left_sec,  10))
        self.right = float(np.percentile(right_sec, 10))

    def scan_callback(self, msg):
        # Clean ranges
        ranges = np.array(msg.ranges, dtype=float)
        ranges = np.where(np.isfinite(ranges), ranges, 10.0)
        self.ranges_full = ranges

        angle_min = msg.angle_min
        angle_inc = msg.angle_increment
        N = len(ranges)

        def angle_to_idx(angle):
            return int((angle - angle_min) / angle_inc)

        # Define cardinal angles
        FRONT = 0.0
        LEFT  = math.pi/2
        RIGHT = -math.pi/2

        w = math.radians(12)   # ¬±12¬∞ window

        def median_in_sector(center_angle):
            idx0 = angle_to_idx(center_angle - w)
            idx1 = angle_to_idx(center_angle + w)

            # clip indices
            idx0 %= N
            idx1 %= N

            if idx0 <= idx1:
                sector = ranges[idx0:idx1]
            else:
                # wrap-around case (e.g., crossing the 0¬∞ boundary)
                sector = np.concatenate((ranges[idx0:], ranges[:idx1]))

            return float(np.median(sector))

        self.front = median_in_sector(FRONT)
        self.left  = median_in_sector(LEFT)
        self.right = median_in_sector(RIGHT)



    # ---------------- ODOM ----------------
    def odom_callback(self, msg):
        self.robot_x = msg.pose.pose.position.x
        self.robot_y = msg.pose.pose.position.y
        q = msg.pose.pose.orientation
        siny = 2*(q.w*q.z + q.x*q.y)
        cosy = 1 - 2*(q.y*q.y + q.z*q.z)
        self.robot_yaw = math.atan2(siny, cosy)

    # ---------------- MAP ----------------
    def map_callback(self, msg):
        # msg.data is a flat list row-major. reshape to [height, width]
        self.map_data = np.array(msg.data, dtype=int).reshape(msg.info.height, msg.info.width)
        self.map_width = msg.info.width
        self.map_height = msg.info.height
        self.map_res = msg.info.resolution
        self.map_origin = (msg.info.origin.position.x, msg.info.origin.position.y)
        # bump seq to notice map changes
        self.map_seq += 1

        # build inflated map (binary grid) whenever map updates
        self.inflated_map = self.build_inflated_map(self.map_data, INFLATE_RADIUS)

        # initialize visited_mask to False with same shape as map
        if self.visited_mask is None:
            self.visited_mask = np.zeros_like(self.map_data, dtype=bool)
        else:
            # Resize mask if map grows (SLAM expanding map)
            if self.visited_mask.shape != self.map_data.shape:
                new_mask = np.zeros_like(self.map_data, dtype=bool)
                H_old, W_old = self.visited_mask.shape
                H_new, W_new = new_mask.shape
                h = min(H_old, H_new)
                w = min(W_old, W_new)
                new_mask[:h, :w] = self.visited_mask[:h, :w]
                self.visited_mask = new_mask



    # ---------------- INFLATION ----------------
    def build_inflated_map(self, M, radius_cells):
        H, W = M.shape
        binmap = np.zeros((H, W), dtype=np.uint8)
        binmap[M >= OCCUPIED_THRESH] = 1

        if radius_cells <= 0:
            return binmap

        # Optionally reduce inflation near narrow hallways
        # Example: detect narrow corridors by checking free neighbors
        corridor_mask = np.zeros_like(binmap, dtype=bool)
        for y in range(1,H-1):
            for x in range(1,W-1):
                if binmap[y,x] == 0:
                    # Count free neighbors (4-connectivity)
                    free_count = np.sum(binmap[y-1:y+2, x-1:x+2]==0)
                    if free_count <= 3:
                        corridor_mask[y,x] = True

        inflated = binmap.copy()
        dist = np.full((H, W), -1, dtype=int)
        q = deque()
        ys, xs = np.where(binmap == 1)
        for y, x in zip(ys, xs):
            q.append((y, x))
            dist[y, x] = 0

        offs = [(-1,0),(1,0),(0,-1),(0,1),(-1,-1),(-1,1),(1,-1),(1,1)]
        while q:
            y, x = q.popleft()
            d = dist[y, x]
            if d >= radius_cells:
                continue
            for dy, dx in offs:
                ny, nx = y + dy, x + dx
                if 0 <= ny < H and 0 <= nx < W and dist[ny, nx] == -1:
                    dist[ny, nx] = d + 1
                    # reduce inflation in corridor cells
                    if not corridor_mask[ny, nx]:
                        inflated[ny, nx] = 1
                    q.append((ny, nx))

        return inflated


    # ---------------- FRONTIER / PLANNING HELPERS ----------------
    def get_frontier_cells(self):
        """
        Return list of free cells (x,y) that border unknown cells.
        free cell: map_data[y,x] == 0
        unknown cell: map_data[y,x] == UNKNOWN_VAL
        """
        if self.map_data is None:
            return []

        frontiers = []
        M = self.map_data
        H, W = M.shape

        # don't check border cells (1..H-2, 1..W-2) for safety
        for y in range(1, H-1):
            for x in range(1, W-1):
                if M[y, x] != 0:
                    continue
                # check 8-neighborhood for unknown
                neigh = M[y-1:y+2, x-1:x+2]
                if np.any(neigh == UNKNOWN_VAL):
                    frontiers.append((x, y))
        return frontiers

    def is_cell_free_inflated(self, gx, gy):
        """Return True if inflated_map considers this cell free (0)."""
        if self.inflated_map is None:
            return False
        if not (0 <= gx < self.map_width and 0 <= gy < self.map_height):
            return False
        return self.inflated_map[gy, gx] == 0

    # -----------------------------------------------------
    #      PLANNING: choose reachable frontier -> A*
    # -----------------------------------------------------
    def plan_to_frontier(self, farthest=False):
        M = self.map_data
        H, W = M.shape
        if self.map_data is None or self.inflated_map is None:
            return False

        frontiers = self.get_frontier_cells()
        self.get_logger().info(f"Frontiers found: {len(frontiers)}")
        # ==== REACHABILITY FILTER (fixes wall-pushing bug) ====
        """rx, ry = self.world_to_grid(self.robot_x, self.robot_y)

        reachable = np.zeros_like(self.inflated_map, dtype=bool)
        queue = [(rx, ry)]
        reachable[ry, rx] = True

        while queue:
            x, y = queue.pop()
            for nx, ny in ((x+1,y), (x-1,y), (x,y+1), (x,y-1)):
                if 0 <= nx < W and 0 <= ny < H:
                    if self.inflated_map[ny, nx] == 0 and not reachable[ny, nx]:
                        reachable[ny, nx] = True
                        queue.append((nx, ny))

        # Filter frontiers by reachability
        frontiers = [(fx, fy) for (fx, fy) in frontiers if reachable[fy, fx]]

        self.get_logger().info(f"Reachable frontiers after filtering: {len(frontiers)}")
"""
        if not frontiers:
            return False
        
        # Filter visited & failed frontiers
        filtered_frontiers = []
        now = time.time()

        for fx, fy in frontiers:
            # skip if visited
            if self.visited_mask is not None and self.visited_mask[fy, fx]:
                continue

            # skip if failed too many times
            fail_count = self.failed_frontiers.get((fx, fy), 0)
            if fail_count >= self.FAILED_LIMIT:
                # clear failed entry if stale
                ts = self._failed_timestamps.get((fx, fy), 0)
                if now - ts > self.FAILED_CLEAR_TIME:
                    self.failed_frontiers.pop((fx, fy), None)
                    self._failed_timestamps.pop((fx, fy), None)
                else:
                    continue

            filtered_frontiers.append((fx, fy))

        if not filtered_frontiers:
            return False

        # Robot grid
        rx, ry = self.world_to_grid(self.robot_x, self.robot_y)
        F = np.array(filtered_frontiers, dtype=float)
        dx = F[:, 0] - rx
        dy = F[:, 1] - ry
        dist = np.hypot(dx, dy)

        # Direction preference
        if self.exploration_dir is None:
            ex, ey = (math.cos(self.robot_yaw), math.sin(self.robot_yaw))
        else:
            ex, ey = self.exploration_dir

        with np.errstate(divide='ignore', invalid='ignore'):
            ux = np.where(dist > 0, dx / dist, 0.0)
            uy = np.where(dist > 0, dy / dist, 0.0)

        dots = ux * ex + uy * ey  # directional alignment score

        # Score = alignment * (1 + normalized distance)
        maxd = max(1.0, float(np.max(dist)))
        scores = dots * (1.0 + dist / maxd)

        # Prefer frontiers roughly ahead of robot
        cos_limit = math.cos(self.EXPLORE_ANGLE_LIMIT)
        ahead_idxs = np.where(dots >= cos_limit)[0]
        weak_idxs = np.where(dots >= 0.0)[0]

        if ahead_idxs.size > 0:
            candidate_order = ahead_idxs[np.argsort(scores[ahead_idxs])[::-1]]
        elif weak_idxs.size > 0:
            candidate_order = weak_idxs[np.argsort(scores[weak_idxs])[::-1]]
        else:
            candidate_order = np.argsort(scores)[::-1]

        # Try each candidate in ranked order
        for idx in candidate_order:
            fx, fy = int(F[idx, 0]), int(F[idx, 1])
            frontier = (fx, fy)

            # FIND SAFE TARGET
            safe_target = self.find_safe_target_near_frontier(fx, fy)
            if safe_target is None:
                # mark failure
                self.failed_frontiers[frontier] = self.failed_frontiers.get(frontier, 0) + 1
                self._failed_timestamps[frontier] = now
                continue

            # Now run A*
            start = (rx, ry)
            goal = safe_target
            path = self.astar_grid(start, goal)

            if path:
                # success
                self.current_path = path
                self.current_path_world = [self.grid_to_world(x, y) for x, y in path]

                # store frontier (not safe target)
                self.path_goal = frontier

                # reset progress tracking
                self.last_progress_dist = None
                self.last_progress_time = now
                self.last_progress_path_seq = self.map_seq

                self.get_logger().info(f"üìç Path to frontier={frontier} via safe={safe_target}, len={len(path)}")
                return True

            # A* failed ‚Üí mark this frontier failed
            self.failed_frontiers[frontier] = self.failed_frontiers.get(frontier, 0) + 1
            self._failed_timestamps[frontier] = now

        # Fallback: try all by distance
        order2 = np.argsort(dist)
        for idx in order2:
            fx, fy = int(F[idx, 0]), int(F[idx, 1])
            frontier = (fx, fy)

            safe_target = self.find_safe_target_near_frontier(fx, fy)
            if safe_target is None:
                continue

            path = self.astar_grid((rx, ry), safe_target)
            if not path:
                continue

            self.current_path = path
            self.current_path_world = [self.grid_to_world(x, y) for x, y in path]
            self.path_goal = frontier
            self.last_progress_dist = None
            self.last_progress_time = now
            self.last_progress_path_seq = self.map_seq

            self.get_logger().info(f"üìç Fallback path to frontier={frontier} safe={safe_target}")
            return True

        return False


    def find_safe_target_near_frontier(self, fx, fy, max_radius=6):
        """
        Search the inflated map around the frontier (fx, fy)
        for the nearest safe navigable cell.
        This prevents the robot from trying to drive into narrow or unsafe spots.
        """

        # if frontier cell itself is free in inflated map, use it
        if self.is_cell_free_inflated(fx, fy):
            return (fx, fy)

        # spiral search outward
        for r in range(1, max_radius + 1):
            for dx in range(-r, r + 1):
                for dy in (-r, r):
                    x, y = fx + dx, fy + dy
                    if self.is_cell_free_inflated(x, y):
                        return (x, y)
            for dy in range(-r + 1, r):
                for dx in (-r, r):
                    x, y = fx + dx, fy + dy
                    if self.is_cell_free_inflated(x, y):
                        return (x, y)

        return None

    # -----------------------------------------------------
    #               A* ON GRID (4-connected)
    # -----------------------------------------------------
    def astar_grid(self, start, goal):
        # start, goal are (gx,gy) tuples
        sx, sy = start
        gx, gy = goal
        H, W = self.map_height, self.map_width

        # bounds
        if not (0 <= gx < W and 0 <= gy < H):
            return None

        # Use inflated_map for occupancy checks (1 == occupied)
        M_infl = self.inflated_map
        # if goal is occupied in inflated map -> fail
        if M_infl[gy, gx] == 1:
            return None
        if M_infl[sy, sx] == 1:
            # start inside obstacle; fail gracefully
            return None

        open_heap = []
        heapq.heappush(open_heap, (0 + self.heuristic(start, goal), 0, start, None))
        came_from = {}
        gscore = {start: 0}
        closed = set()

        neighbors = [(1,0), (-1,0), (0,1), (0,-1)]

        while open_heap:
            f, g, current, parent = heapq.heappop(open_heap)
            if current in closed:
                continue
            came_from[current] = parent
            if current == goal:
                # reconstruct path
                path = []
                node = current
                while node is not None:
                    path.append(node)
                    node = came_from[node]
                path.reverse()
                return path  # list of (gx,gy)
            closed.add(current)

            cx, cy = current
            for dx, dy in neighbors:
                nx, ny = cx + dx, cy + dy
                if not (0 <= nx < W and 0 <= ny < H):
                    continue
                if M_infl[ny, nx] == 1:
                    continue
                neighbor = (nx, ny)
                tentative_g = g + 1
                if tentative_g < gscore.get(neighbor, 1e9):
                    gscore[neighbor] = tentative_g
                    fscore = tentative_g + self.heuristic(neighbor, goal)
                    heapq.heappush(open_heap, (fscore, tentative_g, neighbor, current))

        return None

    def heuristic(self, a, b):
        # Euclidean distance in grid cells
        return math.hypot(a[0]-b[0], a[1]-b[1])

    # -----------------------------------------------------
    #                PATH FOLLOWER
    # -----------------------------------------------------
    def follow_path(self):
        """
        Follow current_path_world waypoints. Returns Twist command.
        """
        if not self.current_path_world:
            return Twist()

        # next waypoint in world coords
        wx, wy = self.current_path_world[0]

        dx = wx - self.robot_x
        dy = wy - self.robot_y
        dist = math.hypot(dx, dy)
        target_angle = math.atan2(dy, dx)
        yaw_error = target_angle - self.robot_yaw
        yaw_error = math.atan2(math.sin(yaw_error), math.cos(yaw_error))

        cmd = Twist()

        # If close to waypoint, pop it
        if dist < GOAL_NEAR_DIST_M:
            self.current_path_world.pop(0)
            self.current_path.pop(0)
            # if path finished
            if not self.current_path_world:
                self.get_logger().info("‚úÖ Reached path goal grid={}, clearing path".format(self.path_goal))
                gx, gy = self.path_goal if self.path_goal is not None else (None, None)
                self.path_goal = None

                # mark visited area on the visited_mask to avoid reselecting nearby frontiers
                if self.visited_mask is not None and gx is not None:
                    rr = self.VISITED_RADIUS
                    H, W = self.map_height, self.map_width
                    x0 = max(0, gx - rr); x1 = min(W, gx + rr + 1)
                    y0 = max(0, gy - rr); y1 = min(H, gy + rr + 1)
                    xs = np.arange(x0, x1)
                    ys = np.arange(y0, y1)
                    # efficient disk mask
                    dx = xs.reshape(1, -1) - gx
                    dy = ys.reshape(-1, 1) - gy
                    d2 = dx*dx + dy*dy
                    disk = d2 <= (rr*rr)
                    # assign into visited_mask (note indexing visited_mask[y,x])
                    self.visited_mask[y0:y1, x0:x1] |= disk

                # reset exploration_dir (keep this)
                self.exploration_dir = None

                """# optionally clear failed_frontiers entries near the goal (they might now be reachable/irrelevant)
                to_delete = []
                if gx is not None:
                    for f in list(self.failed_frontiers.keys()):
                        fx, fy = f
                        if (fx - gx)**2 + (fy - gy)**2 <= (rr*rr):
                            to_delete.append(f)
                for f in to_delete:
                    self.failed_frontiers.pop(f, None)
                    self._failed_timestamps.pop(f, None)"""

                return Twist()



        # Safety override: if obstacle directly in front, rotate in place
        # Safety override: obstacle directly ahead
        if hasattr(self, "front") and self.front < 0.28:
            print("Object in Front")

            # 1. If rotating hasn't helped for 1.5 sec, BACK UP and replan
            t_now = time.time()
            if not hasattr(self, "_front_block_start"):
                self._front_block_start = t_now

            block_time = t_now - self._front_block_start

            # After 1.5 seconds of rotation ‚Üí back up
            if block_time > 1.5:
                cmd.linear.x = -0.06    # gentle reverse
                cmd.angular.z = 0.0
                # Clear path so planner makes a new one
                self.current_path_world = []
                self.current_path = []
                self.path_goal = None
                self.exploration_dir = None
                print("Backing up & clearing path (blocked too long)")
                return cmd

            # 2. For the first 1.5 seconds, rotate away from closest side
            cmd.linear.x = 0.0
            if hasattr(self, "left") and hasattr(self, "right"):
                if self.left < self.right:
                    cmd.angular.z = -0.5
                else:
                    cmd.angular.z = 0.5
            else:
                cmd.angular.z = 0.5

            return cmd

        else:
            # Reset block timer when path is clear
            if hasattr(self, "_front_block_start"):
                del self._front_block_start

        
        # --- hallway centering ---
        # If walls on BOTH sides, center in hallway
        if self.left < 0.8 and self.right < 0.8:
            print("Hallway Detected")
            wall_error = (self.left - self.right)
            hallway_correction = -1.4 * wall_error   # steer away from closer wall
        else:
            hallway_correction = 0.0


        # rotate to face waypoint first if yaw error large
        if abs(yaw_error) > ALIGN_ANGLE:
            ang = max(-MAX_ANGULAR_SPEED, min(MAX_ANGULAR_SPEED, 1.2 * yaw_error))
            if self.detect_oscillation(ang):
                self.get_logger().warn("üîÑ Oscillation detected (rotate) -> forward nudge")
                self.oscillating = True; self.osc_end = time.time() + 0.35
                cmd2 = Twist(); cmd2.linear.x = 0.08; self.cmd_pub.publish(cmd2); return cmd2
            cmd.angular.z = ang; cmd.linear.x = 0.0
            return cmd

        # else drive forward with small angular correction
        cmd.linear.x = min(MAX_LINEAR_SPEED, 0.5 * dist + 0.02)
        # damp speed when near obstacles
        if hasattr(self, "front") and self.front < 0.6:
            cmd.linear.x = min(cmd.linear.x, 0.06)
        cmd.angular.z = max(-MAX_ANGULAR_SPEED, min(MAX_ANGULAR_SPEED, 1.0*yaw_error))
        # oscillation detection on commanded ang
        if self.detect_oscillation(cmd.angular.z):
            self.get_logger().warn("üîÑ Oscillation detected (drive) -> forward nudge")
            self.oscillating = True; self.osc_end = time.time() + 0.35
            ncmd = Twist(); ncmd.linear.x = 0.08; self.cmd_pub.publish(ncmd); return ncmd
        
        return cmd
    
    def detect_oscillation(self, ang_z):
        # count sign flips ignoring small turns
        if abs(ang_z) < 0.1:
            self.osc_count = 0
            self.last_turn_sign = 0
            return False
        sign = 1 if ang_z > 0 else -1
        if self.last_turn_sign != 0 and sign != self.last_turn_sign:
            self.osc_count += 1
        else:
            self.osc_count = 0
        self.last_turn_sign = sign
        if self.osc_count >= self.OSCILLATION_THRESHOLD:
            now = time.time()
            if now - self.osc_last_time > self.OSCILLATION_COOLDOWN:
                self.osc_last_time = now
                self.osc_count = 0
                print("oscillating")
                return True
        return False

    # -----------------------------------------------------
    #                RECOVERY BEHAVIOR
    # -----------------------------------------------------
    def start_recovery(self):
        # start backup stage first then rotate
        self.recovering = True
        self.recovery_stage = "backup"
        self.recovery_end_time = time.time() + BACKUP_TIME

    def recovery_cmd(self):
        cmd = Twist()
        if self.recovery_stage == "backup":
            # back up slowly
            cmd.linear.x = -0.06
            cmd.angular.z = 0.0
            # if time passed, move to rotate
            if time.time() >= self.recovery_end_time:
                self.recovery_stage = "rotate"
                self.recovery_end_time = time.time() + RECOVERY_ROTATE_TIME
                return cmd
            return cmd
        elif self.recovery_stage == "rotate":
            # rotate in place
            cmd.linear.x = 0.0
            cmd.angular.z = 0.6
            return cmd
        else:
            return Twist()

    # -----------------------------------------------------
    #             MAP <-> WORLD helpers
    # -----------------------------------------------------
    def world_to_grid(self, wx, wy):
        gx = int((wx - self.map_origin[0]) / self.map_res)
        gy = int((wy - self.map_origin[1]) / self.map_res)
        # clamp
        gx = max(0, min(self.map_width - 1, gx))
        gy = max(0, min(self.map_height - 1, gy))
        return gx, gy

    def grid_to_world(self, gx, gy):
        wx = self.map_origin[0] + gx * self.map_res + 0.5*self.map_res
        wy = self.map_origin[1] + gy * self.map_res + 0.5*self.map_res
        return wx, wy

def main(args=None):
    rclpy.init(args=args)
    node = Task1()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()